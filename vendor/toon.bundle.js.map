{
  "version": 3,
  "sources": ["../node_modules/@toon-format/toon/dist/index.mjs", "../scripts/toon-entry.js"],
  "sourcesContent": ["//#region src/constants.ts\nconst LIST_ITEM_MARKER = \"-\";\nconst LIST_ITEM_PREFIX = \"- \";\nconst COMMA = \",\";\nconst COLON = \":\";\nconst SPACE = \" \";\nconst PIPE = \"|\";\nconst DOT = \".\";\nconst OPEN_BRACKET = \"[\";\nconst CLOSE_BRACKET = \"]\";\nconst OPEN_BRACE = \"{\";\nconst CLOSE_BRACE = \"}\";\nconst NULL_LITERAL = \"null\";\nconst TRUE_LITERAL = \"true\";\nconst FALSE_LITERAL = \"false\";\nconst BACKSLASH = \"\\\\\";\nconst DOUBLE_QUOTE = \"\\\"\";\nconst NEWLINE = \"\\n\";\nconst CARRIAGE_RETURN = \"\\r\";\nconst TAB = \"\t\";\nconst DELIMITERS = {\n\tcomma: COMMA,\n\ttab: TAB,\n\tpipe: PIPE\n};\nconst DEFAULT_DELIMITER = DELIMITERS.comma;\n\n//#endregion\n//#region src/shared/string-utils.ts\n/**\n* Escapes special characters in a string for encoding.\n*\n* @remarks\n* Handles backslashes, quotes, newlines, carriage returns, and tabs.\n*/\nfunction escapeString(value) {\n\treturn value.replace(/\\\\/g, `${BACKSLASH}${BACKSLASH}`).replace(/\"/g, `${BACKSLASH}${DOUBLE_QUOTE}`).replace(/\\n/g, `${BACKSLASH}n`).replace(/\\r/g, `${BACKSLASH}r`).replace(/\\t/g, `${BACKSLASH}t`);\n}\n/**\n* Unescapes a string by processing escape sequences.\n*\n* @remarks\n* Handles `\\n`, `\\t`, `\\r`, `\\\\`, and `\\\"` escape sequences.\n*/\nfunction unescapeString(value) {\n\tlet unescaped = \"\";\n\tlet i = 0;\n\twhile (i < value.length) {\n\t\tif (value[i] === BACKSLASH) {\n\t\t\tif (i + 1 >= value.length) throw new SyntaxError(\"Invalid escape sequence: backslash at end of string\");\n\t\t\tconst next = value[i + 1];\n\t\t\tif (next === \"n\") {\n\t\t\t\tunescaped += NEWLINE;\n\t\t\t\ti += 2;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (next === \"t\") {\n\t\t\t\tunescaped += TAB;\n\t\t\t\ti += 2;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (next === \"r\") {\n\t\t\t\tunescaped += CARRIAGE_RETURN;\n\t\t\t\ti += 2;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (next === BACKSLASH) {\n\t\t\t\tunescaped += BACKSLASH;\n\t\t\t\ti += 2;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (next === DOUBLE_QUOTE) {\n\t\t\t\tunescaped += DOUBLE_QUOTE;\n\t\t\t\ti += 2;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tthrow new SyntaxError(`Invalid escape sequence: \\\\${next}`);\n\t\t}\n\t\tunescaped += value[i];\n\t\ti++;\n\t}\n\treturn unescaped;\n}\n/**\n* Finds the index of the closing double quote, accounting for escape sequences.\n*/\nfunction findClosingQuote(content, start) {\n\tlet i = start + 1;\n\twhile (i < content.length) {\n\t\tif (content[i] === BACKSLASH && i + 1 < content.length) {\n\t\t\ti += 2;\n\t\t\tcontinue;\n\t\t}\n\t\tif (content[i] === DOUBLE_QUOTE) return i;\n\t\ti++;\n\t}\n\treturn -1;\n}\n/**\n* Finds the index of a character outside of quoted sections.\n*/\nfunction findUnquotedChar(content, char, start = 0) {\n\tlet inQuotes = false;\n\tlet i = start;\n\twhile (i < content.length) {\n\t\tif (content[i] === BACKSLASH && i + 1 < content.length && inQuotes) {\n\t\t\ti += 2;\n\t\t\tcontinue;\n\t\t}\n\t\tif (content[i] === DOUBLE_QUOTE) {\n\t\t\tinQuotes = !inQuotes;\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (content[i] === char && !inQuotes) return i;\n\t\ti++;\n\t}\n\treturn -1;\n}\n\n//#endregion\n//#region src/shared/literal-utils.ts\nfunction isBooleanOrNullLiteral(token) {\n\treturn token === TRUE_LITERAL || token === FALSE_LITERAL || token === NULL_LITERAL;\n}\n/**\n* Checks if a token represents a valid numeric literal.\n*\n* @remarks\n* Rejects numbers with leading zeros (except `\"0\"` itself or decimals like `\"0.5\"`).\n*/\nfunction isNumericLiteral(token) {\n\tif (!token) return false;\n\tif (token.length > 1 && token[0] === \"0\" && token[1] !== \".\") return false;\n\tconst numericValue = Number(token);\n\treturn !Number.isNaN(numericValue) && Number.isFinite(numericValue);\n}\n\n//#endregion\n//#region src/decode/parser.ts\nfunction parseArrayHeaderLine(content, defaultDelimiter) {\n\tconst trimmedToken = content.trimStart();\n\tlet bracketStart = -1;\n\tif (trimmedToken.startsWith(DOUBLE_QUOTE)) {\n\t\tconst closingQuoteIndex = findClosingQuote(trimmedToken, 0);\n\t\tif (closingQuoteIndex === -1) return;\n\t\tif (!trimmedToken.slice(closingQuoteIndex + 1).startsWith(OPEN_BRACKET)) return;\n\t\tconst keyEndIndex = content.length - trimmedToken.length + closingQuoteIndex + 1;\n\t\tbracketStart = content.indexOf(OPEN_BRACKET, keyEndIndex);\n\t} else bracketStart = content.indexOf(OPEN_BRACKET);\n\tif (bracketStart === -1) return;\n\tconst bracketEnd = content.indexOf(CLOSE_BRACKET, bracketStart);\n\tif (bracketEnd === -1) return;\n\tlet colonIndex = bracketEnd + 1;\n\tlet braceEnd = colonIndex;\n\tconst braceStart = content.indexOf(OPEN_BRACE, bracketEnd);\n\tif (braceStart !== -1 && braceStart < content.indexOf(COLON, bracketEnd)) {\n\t\tconst foundBraceEnd = content.indexOf(CLOSE_BRACE, braceStart);\n\t\tif (foundBraceEnd !== -1) braceEnd = foundBraceEnd + 1;\n\t}\n\tcolonIndex = content.indexOf(COLON, Math.max(bracketEnd, braceEnd));\n\tif (colonIndex === -1) return;\n\tlet key;\n\tif (bracketStart > 0) {\n\t\tconst rawKey = content.slice(0, bracketStart).trim();\n\t\tkey = rawKey.startsWith(DOUBLE_QUOTE) ? parseStringLiteral(rawKey) : rawKey;\n\t}\n\tconst afterColon = content.slice(colonIndex + 1).trim();\n\tconst bracketContent = content.slice(bracketStart + 1, bracketEnd);\n\tlet parsedBracket;\n\ttry {\n\t\tparsedBracket = parseBracketSegment(bracketContent, defaultDelimiter);\n\t} catch {\n\t\treturn;\n\t}\n\tconst { length, delimiter } = parsedBracket;\n\tlet fields;\n\tif (braceStart !== -1 && braceStart < colonIndex) {\n\t\tconst foundBraceEnd = content.indexOf(CLOSE_BRACE, braceStart);\n\t\tif (foundBraceEnd !== -1 && foundBraceEnd < colonIndex) fields = parseDelimitedValues(content.slice(braceStart + 1, foundBraceEnd), delimiter).map((field) => parseStringLiteral(field.trim()));\n\t}\n\treturn {\n\t\theader: {\n\t\t\tkey,\n\t\t\tlength,\n\t\t\tdelimiter,\n\t\t\tfields\n\t\t},\n\t\tinlineValues: afterColon || void 0\n\t};\n}\nfunction parseBracketSegment(seg, defaultDelimiter) {\n\tlet content = seg;\n\tlet delimiter = defaultDelimiter;\n\tif (content.endsWith(TAB)) {\n\t\tdelimiter = DELIMITERS.tab;\n\t\tcontent = content.slice(0, -1);\n\t} else if (content.endsWith(PIPE)) {\n\t\tdelimiter = DELIMITERS.pipe;\n\t\tcontent = content.slice(0, -1);\n\t}\n\tconst length = Number.parseInt(content, 10);\n\tif (Number.isNaN(length)) throw new TypeError(`Invalid array length: ${seg}`);\n\treturn {\n\t\tlength,\n\t\tdelimiter\n\t};\n}\n/**\n* Parses a delimited string into values, respecting quoted strings and escape sequences.\n*\n* @remarks\n* Uses a state machine that tracks:\n* - `inQuotes`: Whether we're inside a quoted string (to ignore delimiters)\n* - `valueBuffer`: Accumulates characters for the current value\n* - Escape sequences: Handled within quoted strings\n*/\nfunction parseDelimitedValues(input, delimiter) {\n\tconst values = [];\n\tlet valueBuffer = \"\";\n\tlet inQuotes = false;\n\tlet i = 0;\n\twhile (i < input.length) {\n\t\tconst char = input[i];\n\t\tif (char === BACKSLASH && i + 1 < input.length && inQuotes) {\n\t\t\tvalueBuffer += char + input[i + 1];\n\t\t\ti += 2;\n\t\t\tcontinue;\n\t\t}\n\t\tif (char === DOUBLE_QUOTE) {\n\t\t\tinQuotes = !inQuotes;\n\t\t\tvalueBuffer += char;\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (char === delimiter && !inQuotes) {\n\t\t\tvalues.push(valueBuffer.trim());\n\t\t\tvalueBuffer = \"\";\n\t\t\ti++;\n\t\t\tcontinue;\n\t\t}\n\t\tvalueBuffer += char;\n\t\ti++;\n\t}\n\tif (valueBuffer || values.length > 0) values.push(valueBuffer.trim());\n\treturn values;\n}\nfunction mapRowValuesToPrimitives(values) {\n\treturn values.map((v) => parsePrimitiveToken(v));\n}\nfunction parsePrimitiveToken(token) {\n\tconst trimmedToken = token.trim();\n\tif (!trimmedToken) return \"\";\n\tif (trimmedToken.startsWith(DOUBLE_QUOTE)) return parseStringLiteral(trimmedToken);\n\tif (isBooleanOrNullLiteral(trimmedToken)) {\n\t\tif (trimmedToken === TRUE_LITERAL) return true;\n\t\tif (trimmedToken === FALSE_LITERAL) return false;\n\t\tif (trimmedToken === NULL_LITERAL) return null;\n\t}\n\tif (isNumericLiteral(trimmedToken)) {\n\t\tconst parsedNumber = Number.parseFloat(trimmedToken);\n\t\treturn Object.is(parsedNumber, -0) ? 0 : parsedNumber;\n\t}\n\treturn trimmedToken;\n}\nfunction parseStringLiteral(token) {\n\tconst trimmedToken = token.trim();\n\tif (trimmedToken.startsWith(DOUBLE_QUOTE)) {\n\t\tconst closingQuoteIndex = findClosingQuote(trimmedToken, 0);\n\t\tif (closingQuoteIndex === -1) throw new SyntaxError(\"Unterminated string: missing closing quote\");\n\t\tif (closingQuoteIndex !== trimmedToken.length - 1) throw new SyntaxError(\"Unexpected characters after closing quote\");\n\t\treturn unescapeString(trimmedToken.slice(1, closingQuoteIndex));\n\t}\n\treturn trimmedToken;\n}\nfunction parseUnquotedKey(content, start) {\n\tlet parsePosition = start;\n\twhile (parsePosition < content.length && content[parsePosition] !== COLON) parsePosition++;\n\tif (parsePosition >= content.length || content[parsePosition] !== COLON) throw new SyntaxError(\"Missing colon after key\");\n\tconst key = content.slice(start, parsePosition).trim();\n\tparsePosition++;\n\treturn {\n\t\tkey,\n\t\tend: parsePosition\n\t};\n}\nfunction parseQuotedKey(content, start) {\n\tconst closingQuoteIndex = findClosingQuote(content, start);\n\tif (closingQuoteIndex === -1) throw new SyntaxError(\"Unterminated quoted key\");\n\tconst key = unescapeString(content.slice(start + 1, closingQuoteIndex));\n\tlet parsePosition = closingQuoteIndex + 1;\n\tif (parsePosition >= content.length || content[parsePosition] !== COLON) throw new SyntaxError(\"Missing colon after key\");\n\tparsePosition++;\n\treturn {\n\t\tkey,\n\t\tend: parsePosition\n\t};\n}\nfunction parseKeyToken(content, start) {\n\tconst isQuoted = content[start] === DOUBLE_QUOTE;\n\treturn {\n\t\t...isQuoted ? parseQuotedKey(content, start) : parseUnquotedKey(content, start),\n\t\tisQuoted\n\t};\n}\nfunction isArrayHeaderContent(content) {\n\treturn content.trim().startsWith(OPEN_BRACKET) && findUnquotedChar(content, COLON) !== -1;\n}\nfunction isKeyValueContent(content) {\n\treturn findUnquotedChar(content, COLON) !== -1;\n}\n\n//#endregion\n//#region src/decode/scanner.ts\nfunction createScanState() {\n\treturn {\n\t\tlineNumber: 0,\n\t\tblankLines: []\n\t};\n}\nfunction parseLineIncremental(raw, state, indentSize, strict) {\n\tstate.lineNumber++;\n\tconst lineNumber = state.lineNumber;\n\tlet indent = 0;\n\twhile (indent < raw.length && raw[indent] === SPACE) indent++;\n\tconst content = raw.slice(indent);\n\tif (!content.trim()) {\n\t\tconst depth$1 = computeDepthFromIndent(indent, indentSize);\n\t\tstate.blankLines.push({\n\t\t\tlineNumber,\n\t\t\tindent,\n\t\t\tdepth: depth$1\n\t\t});\n\t\treturn;\n\t}\n\tconst depth = computeDepthFromIndent(indent, indentSize);\n\tif (strict) {\n\t\tlet whitespaceEndIndex = 0;\n\t\twhile (whitespaceEndIndex < raw.length && (raw[whitespaceEndIndex] === SPACE || raw[whitespaceEndIndex] === TAB)) whitespaceEndIndex++;\n\t\tif (raw.slice(0, whitespaceEndIndex).includes(TAB)) throw new SyntaxError(`Line ${lineNumber}: Tabs are not allowed in indentation in strict mode`);\n\t\tif (indent > 0 && indent % indentSize !== 0) throw new SyntaxError(`Line ${lineNumber}: Indentation must be exact multiple of ${indentSize}, but found ${indent} spaces`);\n\t}\n\treturn {\n\t\traw,\n\t\tindent,\n\t\tcontent,\n\t\tdepth,\n\t\tlineNumber\n\t};\n}\nfunction* parseLinesSync(source, indentSize, strict, state) {\n\tfor (const raw of source) {\n\t\tconst parsedLine = parseLineIncremental(raw, state, indentSize, strict);\n\t\tif (parsedLine !== void 0) yield parsedLine;\n\t}\n}\nasync function* parseLinesAsync(source, indentSize, strict, state) {\n\tfor await (const raw of source) {\n\t\tconst parsedLine = parseLineIncremental(raw, state, indentSize, strict);\n\t\tif (parsedLine !== void 0) yield parsedLine;\n\t}\n}\nfunction computeDepthFromIndent(indentSpaces, indentSize) {\n\treturn Math.floor(indentSpaces / indentSize);\n}\n\n//#endregion\n//#region src/decode/validation.ts\n/**\n* Asserts that the actual count matches the expected count in strict mode.\n*/\nfunction assertExpectedCount(actual, expected, itemType, options) {\n\tif (options.strict && actual !== expected) throw new RangeError(`Expected ${expected} ${itemType}, but got ${actual}`);\n}\n/**\n* Validates that there are no extra list items beyond the expected count.\n*/\nfunction validateNoExtraListItems(nextLine, itemDepth, expectedCount) {\n\tif (nextLine?.depth === itemDepth && nextLine.content.startsWith(LIST_ITEM_PREFIX)) throw new RangeError(`Expected ${expectedCount} list array items, but found more`);\n}\n/**\n* Validates that there are no extra tabular rows beyond the expected count.\n*/\nfunction validateNoExtraTabularRows(nextLine, rowDepth, header) {\n\tif (nextLine?.depth === rowDepth && !nextLine.content.startsWith(LIST_ITEM_PREFIX) && isDataRow(nextLine.content, header.delimiter)) throw new RangeError(`Expected ${header.length} tabular rows, but found more`);\n}\n/**\n* Validates that there are no blank lines within a specific line range in strict mode.\n*/\nfunction validateNoBlankLinesInRange(startLine, endLine, blankLines, strict, context) {\n\tif (!strict) return;\n\tconst firstBlank = blankLines.find((blank) => blank.lineNumber > startLine && blank.lineNumber < endLine);\n\tif (firstBlank) throw new SyntaxError(`Line ${firstBlank.lineNumber}: Blank lines inside ${context} are not allowed in strict mode`);\n}\n/**\n* Checks if a line is a data row (vs a key-value pair) in a tabular array.\n*/\nfunction isDataRow(content, delimiter) {\n\tconst colonPos = content.indexOf(COLON);\n\tconst delimiterPos = content.indexOf(delimiter);\n\tif (colonPos === -1) return true;\n\tif (delimiterPos !== -1 && delimiterPos < colonPos) return true;\n\treturn false;\n}\n\n//#endregion\n//#region src/decode/decoders.ts\nvar StreamingLineCursor = class {\n\tbuffer = [];\n\tgenerator;\n\tdone = false;\n\tlastLine;\n\tscanState;\n\tconstructor(generator, scanState) {\n\t\tthis.generator = generator;\n\t\tthis.scanState = scanState;\n\t}\n\tgetBlankLines() {\n\t\treturn this.scanState.blankLines;\n\t}\n\tasync peek() {\n\t\tif (this.buffer.length > 0) return this.buffer[0];\n\t\tif (this.done) return;\n\t\tconst result = await this.generator.next();\n\t\tif (result.done) {\n\t\t\tthis.done = true;\n\t\t\treturn;\n\t\t}\n\t\tthis.buffer.push(result.value);\n\t\treturn result.value;\n\t}\n\tasync next() {\n\t\tconst line = await this.peek();\n\t\tif (line !== void 0) {\n\t\t\tthis.buffer.shift();\n\t\t\tthis.lastLine = line;\n\t\t}\n\t\treturn line;\n\t}\n\tasync advance() {\n\t\tawait this.next();\n\t}\n\tcurrent() {\n\t\treturn this.lastLine;\n\t}\n\tasync atEnd() {\n\t\treturn await this.peek() === void 0;\n\t}\n\tpeekSync() {\n\t\tif (this.buffer.length > 0) return this.buffer[0];\n\t\tif (this.done) return;\n\t\tconst result = this.generator.next();\n\t\tif (result.done) {\n\t\t\tthis.done = true;\n\t\t\treturn;\n\t\t}\n\t\tthis.buffer.push(result.value);\n\t\treturn result.value;\n\t}\n\tnextSync() {\n\t\tconst line = this.peekSync();\n\t\tif (line !== void 0) {\n\t\t\tthis.buffer.shift();\n\t\t\tthis.lastLine = line;\n\t\t}\n\t\treturn line;\n\t}\n\tadvanceSync() {\n\t\tthis.nextSync();\n\t}\n\tatEndSync() {\n\t\treturn this.peekSync() === void 0;\n\t}\n};\nfunction* decodeStreamSync$1(source, options) {\n\tif (options?.expandPaths !== void 0) throw new Error(\"expandPaths is not supported in streaming decode\");\n\tconst resolvedOptions = {\n\t\tindent: options?.indent ?? 2,\n\t\tstrict: options?.strict ?? true\n\t};\n\tconst scanState = createScanState();\n\tconst cursor = new StreamingLineCursor(parseLinesSync(source, resolvedOptions.indent, resolvedOptions.strict, scanState), scanState);\n\tconst first = cursor.peekSync();\n\tif (!first) {\n\t\tyield { type: \"startObject\" };\n\t\tyield { type: \"endObject\" };\n\t\treturn;\n\t}\n\tif (isArrayHeaderContent(first.content)) {\n\t\tconst headerInfo = parseArrayHeaderLine(first.content, DEFAULT_DELIMITER);\n\t\tif (headerInfo) {\n\t\t\tcursor.advanceSync();\n\t\t\tyield* decodeArrayFromHeaderSync(headerInfo.header, headerInfo.inlineValues, cursor, 0, resolvedOptions);\n\t\t\treturn;\n\t\t}\n\t}\n\tcursor.advanceSync();\n\tif (!!cursor.atEndSync() && !isKeyValueLineSync(first)) {\n\t\tyield {\n\t\t\ttype: \"primitive\",\n\t\t\tvalue: parsePrimitiveToken(first.content.trim())\n\t\t};\n\t\treturn;\n\t}\n\tyield { type: \"startObject\" };\n\tyield* decodeKeyValueSync(first.content, cursor, 0, resolvedOptions);\n\twhile (!cursor.atEndSync()) {\n\t\tconst line = cursor.peekSync();\n\t\tif (!line || line.depth !== 0) break;\n\t\tcursor.advanceSync();\n\t\tyield* decodeKeyValueSync(line.content, cursor, 0, resolvedOptions);\n\t}\n\tyield { type: \"endObject\" };\n}\nfunction* decodeKeyValueSync(content, cursor, baseDepth, options) {\n\tconst arrayHeader = parseArrayHeaderLine(content, DEFAULT_DELIMITER);\n\tif (arrayHeader && arrayHeader.header.key) {\n\t\tyield {\n\t\t\ttype: \"key\",\n\t\t\tkey: arrayHeader.header.key\n\t\t};\n\t\tyield* decodeArrayFromHeaderSync(arrayHeader.header, arrayHeader.inlineValues, cursor, baseDepth, options);\n\t\treturn;\n\t}\n\tconst { key, isQuoted } = parseKeyToken(content, 0);\n\tconst colonIndex = content.indexOf(COLON, key.length);\n\tconst rest = colonIndex >= 0 ? content.slice(colonIndex + 1).trim() : \"\";\n\tyield isQuoted ? {\n\t\ttype: \"key\",\n\t\tkey,\n\t\twasQuoted: true\n\t} : {\n\t\ttype: \"key\",\n\t\tkey\n\t};\n\tif (!rest) {\n\t\tconst nextLine = cursor.peekSync();\n\t\tif (nextLine && nextLine.depth > baseDepth) {\n\t\t\tyield { type: \"startObject\" };\n\t\t\tyield* decodeObjectFieldsSync(cursor, baseDepth + 1, options);\n\t\t\tyield { type: \"endObject\" };\n\t\t\treturn;\n\t\t}\n\t\tyield { type: \"startObject\" };\n\t\tyield { type: \"endObject\" };\n\t\treturn;\n\t}\n\tyield {\n\t\ttype: \"primitive\",\n\t\tvalue: parsePrimitiveToken(rest)\n\t};\n}\nfunction* decodeObjectFieldsSync(cursor, baseDepth, options) {\n\tlet computedDepth;\n\twhile (!cursor.atEndSync()) {\n\t\tconst line = cursor.peekSync();\n\t\tif (!line || line.depth < baseDepth) break;\n\t\tif (computedDepth === void 0 && line.depth >= baseDepth) computedDepth = line.depth;\n\t\tif (line.depth === computedDepth) {\n\t\t\tcursor.advanceSync();\n\t\t\tyield* decodeKeyValueSync(line.content, cursor, computedDepth, options);\n\t\t} else break;\n\t}\n}\nfunction* decodeArrayFromHeaderSync(header, inlineValues, cursor, baseDepth, options) {\n\tyield {\n\t\ttype: \"startArray\",\n\t\tlength: header.length\n\t};\n\tif (inlineValues) {\n\t\tyield* decodeInlinePrimitiveArraySync(header, inlineValues, options);\n\t\tyield { type: \"endArray\" };\n\t\treturn;\n\t}\n\tif (header.fields && header.fields.length > 0) {\n\t\tyield* decodeTabularArraySync(header, cursor, baseDepth, options);\n\t\tyield { type: \"endArray\" };\n\t\treturn;\n\t}\n\tyield* decodeListArraySync(header, cursor, baseDepth, options);\n\tyield { type: \"endArray\" };\n}\nfunction* decodeInlinePrimitiveArraySync(header, inlineValues, options) {\n\tif (!inlineValues.trim()) {\n\t\tassertExpectedCount(0, header.length, \"inline array items\", options);\n\t\treturn;\n\t}\n\tconst primitives = mapRowValuesToPrimitives(parseDelimitedValues(inlineValues, header.delimiter));\n\tassertExpectedCount(primitives.length, header.length, \"inline array items\", options);\n\tfor (const primitive of primitives) yield {\n\t\ttype: \"primitive\",\n\t\tvalue: primitive\n\t};\n}\nfunction* decodeTabularArraySync(header, cursor, baseDepth, options) {\n\tconst rowDepth = baseDepth + 1;\n\tlet rowCount = 0;\n\tlet startLine;\n\tlet endLine;\n\twhile (!cursor.atEndSync() && rowCount < header.length) {\n\t\tconst line = cursor.peekSync();\n\t\tif (!line || line.depth < rowDepth) break;\n\t\tif (line.depth === rowDepth) {\n\t\t\tif (startLine === void 0) startLine = line.lineNumber;\n\t\t\tendLine = line.lineNumber;\n\t\t\tcursor.advanceSync();\n\t\t\tconst values = parseDelimitedValues(line.content, header.delimiter);\n\t\t\tassertExpectedCount(values.length, header.fields.length, \"tabular row values\", options);\n\t\t\tconst primitives = mapRowValuesToPrimitives(values);\n\t\t\tyield* yieldObjectFromFields(header.fields, primitives);\n\t\t\trowCount++;\n\t\t} else break;\n\t}\n\tassertExpectedCount(rowCount, header.length, \"tabular rows\", options);\n\tif (options.strict && startLine !== void 0 && endLine !== void 0) validateNoBlankLinesInRange(startLine, endLine, cursor.getBlankLines(), options.strict, \"tabular array\");\n\tif (options.strict) validateNoExtraTabularRows(cursor.peekSync(), rowDepth, header);\n}\nfunction* decodeListArraySync(header, cursor, baseDepth, options) {\n\tconst itemDepth = baseDepth + 1;\n\tlet itemCount = 0;\n\tlet startLine;\n\tlet endLine;\n\twhile (!cursor.atEndSync() && itemCount < header.length) {\n\t\tconst line = cursor.peekSync();\n\t\tif (!line || line.depth < itemDepth) break;\n\t\tconst isListItem = line.content.startsWith(LIST_ITEM_PREFIX) || line.content === LIST_ITEM_MARKER;\n\t\tif (line.depth === itemDepth && isListItem) {\n\t\t\tif (startLine === void 0) startLine = line.lineNumber;\n\t\t\tendLine = line.lineNumber;\n\t\t\tyield* decodeListItemSync(cursor, itemDepth, options);\n\t\t\tconst currentLine = cursor.current();\n\t\t\tif (currentLine) endLine = currentLine.lineNumber;\n\t\t\titemCount++;\n\t\t} else break;\n\t}\n\tassertExpectedCount(itemCount, header.length, \"list array items\", options);\n\tif (options.strict && startLine !== void 0 && endLine !== void 0) validateNoBlankLinesInRange(startLine, endLine, cursor.getBlankLines(), options.strict, \"list array\");\n\tif (options.strict) validateNoExtraListItems(cursor.peekSync(), itemDepth, header.length);\n}\nfunction* decodeListItemSync(cursor, baseDepth, options) {\n\tconst line = cursor.nextSync();\n\tif (!line) throw new ReferenceError(\"Expected list item\");\n\tlet afterHyphen;\n\tif (line.content === LIST_ITEM_MARKER) {\n\t\tconst followDepth = baseDepth + 1;\n\t\tconst nextLine = cursor.peekSync();\n\t\tif (!nextLine || nextLine.depth < followDepth) {\n\t\t\tyield { type: \"startObject\" };\n\t\t\tyield { type: \"endObject\" };\n\t\t\treturn;\n\t\t}\n\t\tif (nextLine.depth === followDepth && !nextLine.content.startsWith(LIST_ITEM_PREFIX)) {\n\t\t\tyield { type: \"startObject\" };\n\t\t\twhile (!cursor.atEndSync()) {\n\t\t\t\tconst fieldLine = cursor.peekSync();\n\t\t\t\tif (!fieldLine || fieldLine.depth < followDepth) break;\n\t\t\t\tif (fieldLine.depth === followDepth && !fieldLine.content.startsWith(LIST_ITEM_PREFIX)) {\n\t\t\t\t\tcursor.advanceSync();\n\t\t\t\t\tyield* decodeKeyValueSync(fieldLine.content, cursor, followDepth, options);\n\t\t\t\t} else break;\n\t\t\t}\n\t\t\tyield { type: \"endObject\" };\n\t\t\treturn;\n\t\t} else {\n\t\t\tyield { type: \"startObject\" };\n\t\t\tyield { type: \"endObject\" };\n\t\t\treturn;\n\t\t}\n\t} else if (line.content.startsWith(LIST_ITEM_PREFIX)) afterHyphen = line.content.slice(LIST_ITEM_PREFIX.length);\n\telse throw new SyntaxError(`Expected list item to start with \"${LIST_ITEM_PREFIX}\"`);\n\tif (!afterHyphen.trim()) {\n\t\tyield { type: \"startObject\" };\n\t\tyield { type: \"endObject\" };\n\t\treturn;\n\t}\n\tif (isArrayHeaderContent(afterHyphen)) {\n\t\tconst arrayHeader = parseArrayHeaderLine(afterHyphen, DEFAULT_DELIMITER);\n\t\tif (arrayHeader) {\n\t\t\tyield* decodeArrayFromHeaderSync(arrayHeader.header, arrayHeader.inlineValues, cursor, baseDepth, options);\n\t\t\treturn;\n\t\t}\n\t}\n\tconst headerInfo = parseArrayHeaderLine(afterHyphen, DEFAULT_DELIMITER);\n\tif (headerInfo && headerInfo.header.key && headerInfo.header.fields) {\n\t\tconst header = headerInfo.header;\n\t\tyield { type: \"startObject\" };\n\t\tyield {\n\t\t\ttype: \"key\",\n\t\t\tkey: header.key\n\t\t};\n\t\tyield* decodeArrayFromHeaderSync(header, headerInfo.inlineValues, cursor, baseDepth + 1, options);\n\t\tconst followDepth = baseDepth + 1;\n\t\twhile (!cursor.atEndSync()) {\n\t\t\tconst nextLine = cursor.peekSync();\n\t\t\tif (!nextLine || nextLine.depth < followDepth) break;\n\t\t\tif (nextLine.depth === followDepth && !nextLine.content.startsWith(LIST_ITEM_PREFIX)) {\n\t\t\t\tcursor.advanceSync();\n\t\t\t\tyield* decodeKeyValueSync(nextLine.content, cursor, followDepth, options);\n\t\t\t} else break;\n\t\t}\n\t\tyield { type: \"endObject\" };\n\t\treturn;\n\t}\n\tif (isKeyValueContent(afterHyphen)) {\n\t\tyield { type: \"startObject\" };\n\t\tyield* decodeKeyValueSync(afterHyphen, cursor, baseDepth + 1, options);\n\t\tconst followDepth = baseDepth + 1;\n\t\twhile (!cursor.atEndSync()) {\n\t\t\tconst nextLine = cursor.peekSync();\n\t\t\tif (!nextLine || nextLine.depth < followDepth) break;\n\t\t\tif (nextLine.depth === followDepth && !nextLine.content.startsWith(LIST_ITEM_PREFIX)) {\n\t\t\t\tcursor.advanceSync();\n\t\t\t\tyield* decodeKeyValueSync(nextLine.content, cursor, followDepth, options);\n\t\t\t} else break;\n\t\t}\n\t\tyield { type: \"endObject\" };\n\t\treturn;\n\t}\n\tyield {\n\t\ttype: \"primitive\",\n\t\tvalue: parsePrimitiveToken(afterHyphen)\n\t};\n}\nfunction isKeyValueLineSync(line) {\n\tconst content = line.content;\n\tif (content.startsWith(\"\\\"\")) {\n\t\tconst closingQuoteIndex = findClosingQuote(content, 0);\n\t\tif (closingQuoteIndex === -1) return false;\n\t\treturn content.slice(closingQuoteIndex + 1).includes(COLON);\n\t} else return content.includes(COLON);\n}\nasync function* decodeStream$1(source, options) {\n\tif (options?.expandPaths !== void 0) throw new Error(\"expandPaths is not supported in streaming decode\");\n\tconst resolvedOptions = {\n\t\tindent: options?.indent ?? 2,\n\t\tstrict: options?.strict ?? true\n\t};\n\tconst scanState = createScanState();\n\tif (Symbol.asyncIterator in source) {\n\t\tconst cursor = new StreamingLineCursor(parseLinesAsync(source, resolvedOptions.indent, resolvedOptions.strict, scanState), scanState);\n\t\tconst first = await cursor.peek();\n\t\tif (!first) {\n\t\t\tyield { type: \"startObject\" };\n\t\t\tyield { type: \"endObject\" };\n\t\t\treturn;\n\t\t}\n\t\tif (isArrayHeaderContent(first.content)) {\n\t\t\tconst headerInfo = parseArrayHeaderLine(first.content, DEFAULT_DELIMITER);\n\t\t\tif (headerInfo) {\n\t\t\t\tawait cursor.advance();\n\t\t\t\tyield* decodeArrayFromHeaderAsync(headerInfo.header, headerInfo.inlineValues, cursor, 0, resolvedOptions);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tawait cursor.advance();\n\t\tif (!!await cursor.atEnd() && !isKeyValueLineSync(first)) {\n\t\t\tyield {\n\t\t\t\ttype: \"primitive\",\n\t\t\t\tvalue: parsePrimitiveToken(first.content.trim())\n\t\t\t};\n\t\t\treturn;\n\t\t}\n\t\tyield { type: \"startObject\" };\n\t\tyield* decodeKeyValueAsync(first.content, cursor, 0, resolvedOptions);\n\t\twhile (!await cursor.atEnd()) {\n\t\t\tconst line = await cursor.peek();\n\t\t\tif (!line || line.depth !== 0) break;\n\t\t\tawait cursor.advance();\n\t\t\tyield* decodeKeyValueAsync(line.content, cursor, 0, resolvedOptions);\n\t\t}\n\t\tyield { type: \"endObject\" };\n\t} else yield* decodeStreamSync$1(source, options);\n}\nasync function* decodeKeyValueAsync(content, cursor, baseDepth, options) {\n\tconst arrayHeader = parseArrayHeaderLine(content, DEFAULT_DELIMITER);\n\tif (arrayHeader && arrayHeader.header.key) {\n\t\tyield {\n\t\t\ttype: \"key\",\n\t\t\tkey: arrayHeader.header.key\n\t\t};\n\t\tyield* decodeArrayFromHeaderAsync(arrayHeader.header, arrayHeader.inlineValues, cursor, baseDepth, options);\n\t\treturn;\n\t}\n\tconst { key, isQuoted } = parseKeyToken(content, 0);\n\tconst colonIndex = content.indexOf(COLON, key.length);\n\tconst rest = colonIndex >= 0 ? content.slice(colonIndex + 1).trim() : \"\";\n\tyield isQuoted ? {\n\t\ttype: \"key\",\n\t\tkey,\n\t\twasQuoted: true\n\t} : {\n\t\ttype: \"key\",\n\t\tkey\n\t};\n\tif (!rest) {\n\t\tconst nextLine = await cursor.peek();\n\t\tif (nextLine && nextLine.depth > baseDepth) {\n\t\t\tyield { type: \"startObject\" };\n\t\t\tyield* decodeObjectFieldsAsync(cursor, baseDepth + 1, options);\n\t\t\tyield { type: \"endObject\" };\n\t\t\treturn;\n\t\t}\n\t\tyield { type: \"startObject\" };\n\t\tyield { type: \"endObject\" };\n\t\treturn;\n\t}\n\tyield {\n\t\ttype: \"primitive\",\n\t\tvalue: parsePrimitiveToken(rest)\n\t};\n}\nasync function* decodeObjectFieldsAsync(cursor, baseDepth, options) {\n\tlet computedDepth;\n\twhile (!await cursor.atEnd()) {\n\t\tconst line = await cursor.peek();\n\t\tif (!line || line.depth < baseDepth) break;\n\t\tif (computedDepth === void 0 && line.depth >= baseDepth) computedDepth = line.depth;\n\t\tif (line.depth === computedDepth) {\n\t\t\tawait cursor.advance();\n\t\t\tyield* decodeKeyValueAsync(line.content, cursor, computedDepth, options);\n\t\t} else break;\n\t}\n}\nasync function* decodeArrayFromHeaderAsync(header, inlineValues, cursor, baseDepth, options) {\n\tyield {\n\t\ttype: \"startArray\",\n\t\tlength: header.length\n\t};\n\tif (inlineValues) {\n\t\tyield* decodeInlinePrimitiveArraySync(header, inlineValues, options);\n\t\tyield { type: \"endArray\" };\n\t\treturn;\n\t}\n\tif (header.fields && header.fields.length > 0) {\n\t\tyield* decodeTabularArrayAsync(header, cursor, baseDepth, options);\n\t\tyield { type: \"endArray\" };\n\t\treturn;\n\t}\n\tyield* decodeListArrayAsync(header, cursor, baseDepth, options);\n\tyield { type: \"endArray\" };\n}\nasync function* decodeTabularArrayAsync(header, cursor, baseDepth, options) {\n\tconst rowDepth = baseDepth + 1;\n\tlet rowCount = 0;\n\tlet startLine;\n\tlet endLine;\n\twhile (!await cursor.atEnd() && rowCount < header.length) {\n\t\tconst line = await cursor.peek();\n\t\tif (!line || line.depth < rowDepth) break;\n\t\tif (line.depth === rowDepth) {\n\t\t\tif (startLine === void 0) startLine = line.lineNumber;\n\t\t\tendLine = line.lineNumber;\n\t\t\tawait cursor.advance();\n\t\t\tconst values = parseDelimitedValues(line.content, header.delimiter);\n\t\t\tassertExpectedCount(values.length, header.fields.length, \"tabular row values\", options);\n\t\t\tconst primitives = mapRowValuesToPrimitives(values);\n\t\t\tyield* yieldObjectFromFields(header.fields, primitives);\n\t\t\trowCount++;\n\t\t} else break;\n\t}\n\tassertExpectedCount(rowCount, header.length, \"tabular rows\", options);\n\tif (options.strict && startLine !== void 0 && endLine !== void 0) validateNoBlankLinesInRange(startLine, endLine, cursor.getBlankLines(), options.strict, \"tabular array\");\n\tif (options.strict) validateNoExtraTabularRows(await cursor.peek(), rowDepth, header);\n}\nasync function* decodeListArrayAsync(header, cursor, baseDepth, options) {\n\tconst itemDepth = baseDepth + 1;\n\tlet itemCount = 0;\n\tlet startLine;\n\tlet endLine;\n\twhile (!await cursor.atEnd() && itemCount < header.length) {\n\t\tconst line = await cursor.peek();\n\t\tif (!line || line.depth < itemDepth) break;\n\t\tconst isListItem = line.content.startsWith(LIST_ITEM_PREFIX) || line.content === LIST_ITEM_MARKER;\n\t\tif (line.depth === itemDepth && isListItem) {\n\t\t\tif (startLine === void 0) startLine = line.lineNumber;\n\t\t\tendLine = line.lineNumber;\n\t\t\tyield* decodeListItemAsync(cursor, itemDepth, options);\n\t\t\tconst currentLine = cursor.current();\n\t\t\tif (currentLine) endLine = currentLine.lineNumber;\n\t\t\titemCount++;\n\t\t} else break;\n\t}\n\tassertExpectedCount(itemCount, header.length, \"list array items\", options);\n\tif (options.strict && startLine !== void 0 && endLine !== void 0) validateNoBlankLinesInRange(startLine, endLine, cursor.getBlankLines(), options.strict, \"list array\");\n\tif (options.strict) validateNoExtraListItems(await cursor.peek(), itemDepth, header.length);\n}\nasync function* decodeListItemAsync(cursor, baseDepth, options) {\n\tconst line = await cursor.next();\n\tif (!line) throw new ReferenceError(\"Expected list item\");\n\tlet afterHyphen;\n\tif (line.content === LIST_ITEM_MARKER) {\n\t\tconst followDepth = baseDepth + 1;\n\t\tconst nextLine = await cursor.peek();\n\t\tif (!nextLine || nextLine.depth < followDepth) {\n\t\t\tyield { type: \"startObject\" };\n\t\t\tyield { type: \"endObject\" };\n\t\t\treturn;\n\t\t}\n\t\tif (nextLine.depth === followDepth && !nextLine.content.startsWith(LIST_ITEM_PREFIX)) {\n\t\t\tyield { type: \"startObject\" };\n\t\t\twhile (!cursor.atEnd()) {\n\t\t\t\tconst fieldLine = await cursor.peek();\n\t\t\t\tif (!fieldLine || fieldLine.depth < followDepth) break;\n\t\t\t\tif (fieldLine.depth === followDepth && !fieldLine.content.startsWith(LIST_ITEM_PREFIX)) {\n\t\t\t\t\tawait cursor.advance();\n\t\t\t\t\tyield* decodeKeyValueAsync(fieldLine.content, cursor, followDepth, options);\n\t\t\t\t} else break;\n\t\t\t}\n\t\t\tyield { type: \"endObject\" };\n\t\t\treturn;\n\t\t} else {\n\t\t\tyield { type: \"startObject\" };\n\t\t\tyield { type: \"endObject\" };\n\t\t\treturn;\n\t\t}\n\t} else if (line.content.startsWith(LIST_ITEM_PREFIX)) afterHyphen = line.content.slice(LIST_ITEM_PREFIX.length);\n\telse throw new SyntaxError(`Expected list item to start with \"${LIST_ITEM_PREFIX}\"`);\n\tif (!afterHyphen.trim()) {\n\t\tyield { type: \"startObject\" };\n\t\tyield { type: \"endObject\" };\n\t\treturn;\n\t}\n\tif (isArrayHeaderContent(afterHyphen)) {\n\t\tconst arrayHeader = parseArrayHeaderLine(afterHyphen, DEFAULT_DELIMITER);\n\t\tif (arrayHeader) {\n\t\t\tyield* decodeArrayFromHeaderAsync(arrayHeader.header, arrayHeader.inlineValues, cursor, baseDepth, options);\n\t\t\treturn;\n\t\t}\n\t}\n\tconst headerInfo = parseArrayHeaderLine(afterHyphen, DEFAULT_DELIMITER);\n\tif (headerInfo && headerInfo.header.key && headerInfo.header.fields) {\n\t\tconst header = headerInfo.header;\n\t\tyield { type: \"startObject\" };\n\t\tyield {\n\t\t\ttype: \"key\",\n\t\t\tkey: header.key\n\t\t};\n\t\tyield* decodeArrayFromHeaderAsync(header, headerInfo.inlineValues, cursor, baseDepth + 1, options);\n\t\tconst followDepth = baseDepth + 1;\n\t\twhile (!await cursor.atEnd()) {\n\t\t\tconst nextLine = await cursor.peek();\n\t\t\tif (!nextLine || nextLine.depth < followDepth) break;\n\t\t\tif (nextLine.depth === followDepth && !nextLine.content.startsWith(LIST_ITEM_PREFIX)) {\n\t\t\t\tawait cursor.advance();\n\t\t\t\tyield* decodeKeyValueAsync(nextLine.content, cursor, followDepth, options);\n\t\t\t} else break;\n\t\t}\n\t\tyield { type: \"endObject\" };\n\t\treturn;\n\t}\n\tif (isKeyValueContent(afterHyphen)) {\n\t\tyield { type: \"startObject\" };\n\t\tyield* decodeKeyValueAsync(afterHyphen, cursor, baseDepth + 1, options);\n\t\tconst followDepth = baseDepth + 1;\n\t\twhile (!await cursor.atEnd()) {\n\t\t\tconst nextLine = await cursor.peek();\n\t\t\tif (!nextLine || nextLine.depth < followDepth) break;\n\t\t\tif (nextLine.depth === followDepth && !nextLine.content.startsWith(LIST_ITEM_PREFIX)) {\n\t\t\t\tawait cursor.advance();\n\t\t\t\tyield* decodeKeyValueAsync(nextLine.content, cursor, followDepth, options);\n\t\t\t} else break;\n\t\t}\n\t\tyield { type: \"endObject\" };\n\t\treturn;\n\t}\n\tyield {\n\t\ttype: \"primitive\",\n\t\tvalue: parsePrimitiveToken(afterHyphen)\n\t};\n}\nfunction* yieldObjectFromFields(fields, primitives) {\n\tyield { type: \"startObject\" };\n\tfor (let i = 0; i < fields.length; i++) {\n\t\tyield {\n\t\t\ttype: \"key\",\n\t\t\tkey: fields[i]\n\t\t};\n\t\tyield {\n\t\t\ttype: \"primitive\",\n\t\t\tvalue: primitives[i]\n\t\t};\n\t}\n\tyield { type: \"endObject\" };\n}\n\n//#endregion\n//#region src/encode/normalize.ts\nfunction normalizeValue(value) {\n\tif (value === null) return null;\n\tif (typeof value === \"object\" && value !== null && \"toJSON\" in value && typeof value.toJSON === \"function\") {\n\t\tconst next = value.toJSON();\n\t\tif (next !== value) return normalizeValue(next);\n\t}\n\tif (typeof value === \"string\" || typeof value === \"boolean\") return value;\n\tif (typeof value === \"number\") {\n\t\tif (Object.is(value, -0)) return 0;\n\t\tif (!Number.isFinite(value)) return null;\n\t\treturn value;\n\t}\n\tif (typeof value === \"bigint\") {\n\t\tif (value >= Number.MIN_SAFE_INTEGER && value <= Number.MAX_SAFE_INTEGER) return Number(value);\n\t\treturn value.toString();\n\t}\n\tif (value instanceof Date) return value.toISOString();\n\tif (Array.isArray(value)) return value.map(normalizeValue);\n\tif (value instanceof Set) return Array.from(value).map(normalizeValue);\n\tif (value instanceof Map) return Object.fromEntries(Array.from(value, ([k, v]) => [String(k), normalizeValue(v)]));\n\tif (isPlainObject(value)) {\n\t\tconst normalized = {};\n\t\tfor (const key in value) if (Object.prototype.hasOwnProperty.call(value, key)) normalized[key] = normalizeValue(value[key]);\n\t\treturn normalized;\n\t}\n\treturn null;\n}\nfunction isJsonPrimitive(value) {\n\treturn value === null || typeof value === \"string\" || typeof value === \"number\" || typeof value === \"boolean\";\n}\nfunction isJsonArray(value) {\n\treturn Array.isArray(value);\n}\nfunction isJsonObject(value) {\n\treturn value !== null && typeof value === \"object\" && !Array.isArray(value);\n}\nfunction isEmptyObject(value) {\n\treturn Object.keys(value).length === 0;\n}\nfunction isPlainObject(value) {\n\tif (value === null || typeof value !== \"object\") return false;\n\tconst prototype = Object.getPrototypeOf(value);\n\treturn prototype === null || prototype === Object.prototype;\n}\nfunction isArrayOfPrimitives(value) {\n\treturn value.length === 0 || value.every((item) => isJsonPrimitive(item));\n}\nfunction isArrayOfArrays(value) {\n\treturn value.length === 0 || value.every((item) => isJsonArray(item));\n}\nfunction isArrayOfObjects(value) {\n\treturn value.length === 0 || value.every((item) => isJsonObject(item));\n}\n\n//#endregion\n//#region src/shared/validation.ts\n/**\n* Checks if a key can be used without quotes.\n*\n* @remarks\n* Valid unquoted keys must start with a letter or underscore,\n* followed by letters, digits, underscores, or dots.\n*/\nfunction isValidUnquotedKey(key) {\n\treturn /^[A-Z_][\\w.]*$/i.test(key);\n}\n/**\n* Checks if a key segment is a valid identifier for safe folding/expansion.\n*\n* @remarks\n* Identifier segments are more restrictive than unquoted keys:\n* - Must start with a letter or underscore\n* - Followed only by letters, digits, or underscores (no dots)\n* - Used for safe key folding and path expansion\n*/\nfunction isIdentifierSegment(key) {\n\treturn /^[A-Z_]\\w*$/i.test(key);\n}\n/**\n* Determines if a string value can be safely encoded without quotes.\n*\n* @remarks\n* A string needs quoting if it:\n* - Is empty\n* - Has leading or trailing whitespace\n* - Could be confused with a literal (boolean, null, number)\n* - Contains structural characters (colons, brackets, braces)\n* - Contains quotes or backslashes (need escaping)\n* - Contains control characters (newlines, tabs, etc.)\n* - Contains the active delimiter\n* - Starts with a list marker (hyphen)\n*/\nfunction isSafeUnquoted(value, delimiter = DEFAULT_DELIMITER) {\n\tif (!value) return false;\n\tif (value !== value.trim()) return false;\n\tif (isBooleanOrNullLiteral(value) || isNumericLike(value)) return false;\n\tif (value.includes(\":\")) return false;\n\tif (value.includes(\"\\\"\") || value.includes(\"\\\\\")) return false;\n\tif (/[[\\]{}]/.test(value)) return false;\n\tif (/[\\n\\r\\t]/.test(value)) return false;\n\tif (value.includes(delimiter)) return false;\n\tif (value.startsWith(LIST_ITEM_MARKER)) return false;\n\treturn true;\n}\n/**\n* Checks if a string looks like a number.\n*\n* @remarks\n* Match numbers like `42`, `-3.14`, `1e-6`, `05`, etc.\n*/\nfunction isNumericLike(value) {\n\treturn /^-?\\d+(?:\\.\\d+)?(?:e[+-]?\\d+)?$/i.test(value) || /^0\\d+$/.test(value);\n}\n\n//#endregion\n//#region src/decode/expand.ts\n/**\n* Symbol used to mark object keys that were originally quoted in the TOON source.\n* Quoted dotted keys should not be expanded, even if they meet expansion criteria.\n*/\nconst QUOTED_KEY_MARKER = Symbol(\"quotedKey\");\n/**\n* Expands dotted keys into nested objects in safe mode.\n*\n* @remarks\n* This function recursively traverses a decoded TOON value and expands any keys\n* containing dots (`.`) into nested object structures, provided all segments\n* are valid identifiers.\n*\n* Expansion rules:\n* - Keys containing dots are split into segments\n* - All segments must pass `isIdentifierSegment` validation\n* - Non-eligible keys (with special characters) are left as literal dotted keys\n* - Deep merge: When multiple dotted keys expand to the same path, their values are merged if both are objects\n* - Conflict handling:\n*   - `strict=true`: Throws TypeError on conflicts (non-object collision)\n*   - `strict=false`: LWW (silent overwrite)\n*\n* @param value - The decoded value to expand\n* @param strict - Whether to throw errors on conflicts\n* @returns The expanded value with dotted keys reconstructed as nested objects\n* @throws TypeError if conflicts occur in strict mode\n*/\nfunction expandPathsSafe(value, strict) {\n\tif (Array.isArray(value)) return value.map((item) => expandPathsSafe(item, strict));\n\tif (isJsonObject(value)) {\n\t\tconst expandedObject = {};\n\t\tconst quotedKeys = value[QUOTED_KEY_MARKER];\n\t\tfor (const [key, keyValue] of Object.entries(value)) {\n\t\t\tconst isQuoted = quotedKeys?.has(key);\n\t\t\tif (key.includes(DOT) && !isQuoted) {\n\t\t\t\tconst segments = key.split(DOT);\n\t\t\t\tif (segments.every((seg) => isIdentifierSegment(seg))) {\n\t\t\t\t\tinsertPathSafe(expandedObject, segments, expandPathsSafe(keyValue, strict), strict);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst expandedValue = expandPathsSafe(keyValue, strict);\n\t\t\tif (key in expandedObject) {\n\t\t\t\tconst conflictingValue = expandedObject[key];\n\t\t\t\tif (canMerge(conflictingValue, expandedValue)) mergeObjects(conflictingValue, expandedValue, strict);\n\t\t\t\telse {\n\t\t\t\t\tif (strict) throw new TypeError(`Path expansion conflict at key \"${key}\": cannot merge ${typeof conflictingValue} with ${typeof expandedValue}`);\n\t\t\t\t\texpandedObject[key] = expandedValue;\n\t\t\t\t}\n\t\t\t} else expandedObject[key] = expandedValue;\n\t\t}\n\t\treturn expandedObject;\n\t}\n\treturn value;\n}\n/**\n* Inserts a value at a nested path, creating intermediate objects as needed.\n*\n* @remarks\n* This function walks the segment path, creating nested objects as needed.\n* When an existing value is encountered:\n* - If both are objects: deep merge (continue insertion)\n* - If values differ: conflict\n*   - strict=true: throw TypeError\n*   - strict=false: overwrite with new value (LWW)\n*\n* @param target - The object to insert into\n* @param segments - Array of path segments (e.g., ['data', 'metadata', 'items'])\n* @param value - The value to insert at the end of the path\n* @param strict - Whether to throw on conflicts\n* @throws TypeError if a conflict occurs in strict mode\n*/\nfunction insertPathSafe(target, segments, value, strict) {\n\tlet currentNode = target;\n\tfor (let i = 0; i < segments.length - 1; i++) {\n\t\tconst currentSegment = segments[i];\n\t\tconst segmentValue = currentNode[currentSegment];\n\t\tif (segmentValue === void 0) {\n\t\t\tconst newObj = {};\n\t\t\tcurrentNode[currentSegment] = newObj;\n\t\t\tcurrentNode = newObj;\n\t\t} else if (isJsonObject(segmentValue)) currentNode = segmentValue;\n\t\telse {\n\t\t\tif (strict) throw new TypeError(`Path expansion conflict at segment \"${currentSegment}\": expected object but found ${typeof segmentValue}`);\n\t\t\tconst newObj = {};\n\t\t\tcurrentNode[currentSegment] = newObj;\n\t\t\tcurrentNode = newObj;\n\t\t}\n\t}\n\tconst lastSeg = segments[segments.length - 1];\n\tconst destinationValue = currentNode[lastSeg];\n\tif (destinationValue === void 0) currentNode[lastSeg] = value;\n\telse if (canMerge(destinationValue, value)) mergeObjects(destinationValue, value, strict);\n\telse {\n\t\tif (strict) throw new TypeError(`Path expansion conflict at key \"${lastSeg}\": cannot merge ${typeof destinationValue} with ${typeof value}`);\n\t\tcurrentNode[lastSeg] = value;\n\t}\n}\n/**\n* Deep merges properties from source into target.\n*\n* @remarks\n* For each key in source:\n* - If key doesn't exist in target: copy it\n* - If both values are objects: recursively merge\n* - Otherwise: conflict (strict throws, non-strict overwrites)\n*\n* @param target - The target object to merge into\n* @param source - The source object to merge from\n* @param strict - Whether to throw on conflicts\n* @throws TypeError if a conflict occurs in strict mode\n*/\nfunction mergeObjects(target, source, strict) {\n\tfor (const [key, sourceValue] of Object.entries(source)) {\n\t\tconst targetValue = target[key];\n\t\tif (targetValue === void 0) target[key] = sourceValue;\n\t\telse if (canMerge(targetValue, sourceValue)) mergeObjects(targetValue, sourceValue, strict);\n\t\telse {\n\t\t\tif (strict) throw new TypeError(`Path expansion conflict at key \"${key}\": cannot merge ${typeof targetValue} with ${typeof sourceValue}`);\n\t\t\ttarget[key] = sourceValue;\n\t\t}\n\t}\n}\nfunction canMerge(a, b) {\n\treturn isJsonObject(a) && isJsonObject(b);\n}\n\n//#endregion\n//#region src/decode/event-builder.ts\nfunction buildValueFromEvents(events) {\n\tconst state = {\n\t\tstack: [],\n\t\troot: void 0\n\t};\n\tfor (const event of events) applyEvent(state, event);\n\treturn finalizeState(state);\n}\nfunction applyEvent(state, event) {\n\tconst { stack } = state;\n\tswitch (event.type) {\n\t\tcase \"startObject\": {\n\t\t\tconst obj = {};\n\t\t\tconst quotedKeys = /* @__PURE__ */ new Set();\n\t\t\tif (stack.length === 0) stack.push({\n\t\t\t\ttype: \"object\",\n\t\t\t\tobj,\n\t\t\t\tquotedKeys\n\t\t\t});\n\t\t\telse {\n\t\t\t\tconst parent = stack[stack.length - 1];\n\t\t\t\tif (parent.type === \"object\") {\n\t\t\t\t\tif (parent.currentKey === void 0) throw new Error(\"Object startObject event without preceding key\");\n\t\t\t\t\tparent.obj[parent.currentKey] = obj;\n\t\t\t\t\tparent.currentKey = void 0;\n\t\t\t\t} else if (parent.type === \"array\") parent.arr.push(obj);\n\t\t\t\tstack.push({\n\t\t\t\t\ttype: \"object\",\n\t\t\t\t\tobj,\n\t\t\t\t\tquotedKeys\n\t\t\t\t});\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase \"endObject\": {\n\t\t\tif (stack.length === 0) throw new Error(\"Unexpected endObject event\");\n\t\t\tconst context = stack.pop();\n\t\t\tif (context.type !== \"object\") throw new Error(\"Mismatched endObject event\");\n\t\t\tif (context.quotedKeys.size > 0) Object.defineProperty(context.obj, QUOTED_KEY_MARKER, {\n\t\t\t\tvalue: context.quotedKeys,\n\t\t\t\tenumerable: false,\n\t\t\t\twritable: false,\n\t\t\t\tconfigurable: false\n\t\t\t});\n\t\t\tif (stack.length === 0) state.root = context.obj;\n\t\t\tbreak;\n\t\t}\n\t\tcase \"startArray\": {\n\t\t\tconst arr = [];\n\t\t\tif (stack.length === 0) stack.push({\n\t\t\t\ttype: \"array\",\n\t\t\t\tarr\n\t\t\t});\n\t\t\telse {\n\t\t\t\tconst parent = stack[stack.length - 1];\n\t\t\t\tif (parent.type === \"object\") {\n\t\t\t\t\tif (parent.currentKey === void 0) throw new Error(\"Array startArray event without preceding key\");\n\t\t\t\t\tparent.obj[parent.currentKey] = arr;\n\t\t\t\t\tparent.currentKey = void 0;\n\t\t\t\t} else if (parent.type === \"array\") parent.arr.push(arr);\n\t\t\t\tstack.push({\n\t\t\t\t\ttype: \"array\",\n\t\t\t\t\tarr\n\t\t\t\t});\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase \"endArray\": {\n\t\t\tif (stack.length === 0) throw new Error(\"Unexpected endArray event\");\n\t\t\tconst context = stack.pop();\n\t\t\tif (context.type !== \"array\") throw new Error(\"Mismatched endArray event\");\n\t\t\tif (stack.length === 0) state.root = context.arr;\n\t\t\tbreak;\n\t\t}\n\t\tcase \"key\": {\n\t\t\tif (stack.length === 0) throw new Error(\"Key event outside of object context\");\n\t\t\tconst parent = stack[stack.length - 1];\n\t\t\tif (parent.type !== \"object\") throw new Error(\"Key event in non-object context\");\n\t\t\tparent.currentKey = event.key;\n\t\t\tif (event.wasQuoted) parent.quotedKeys.add(event.key);\n\t\t\tbreak;\n\t\t}\n\t\tcase \"primitive\":\n\t\t\tif (stack.length === 0) state.root = event.value;\n\t\t\telse {\n\t\t\t\tconst parent = stack[stack.length - 1];\n\t\t\t\tif (parent.type === \"object\") {\n\t\t\t\t\tif (parent.currentKey === void 0) throw new Error(\"Primitive event without preceding key in object\");\n\t\t\t\t\tparent.obj[parent.currentKey] = event.value;\n\t\t\t\t\tparent.currentKey = void 0;\n\t\t\t\t} else if (parent.type === \"array\") parent.arr.push(event.value);\n\t\t\t}\n\t\t\tbreak;\n\t}\n}\nfunction finalizeState(state) {\n\tif (state.stack.length !== 0) throw new Error(\"Incomplete event stream: stack not empty at end\");\n\tif (state.root === void 0) throw new Error(\"No root value built from events\");\n\treturn state.root;\n}\n\n//#endregion\n//#region src/encode/folding.ts\n/**\n* Attempts to fold a single-key object chain into a dotted path.\n*\n* @remarks\n* Folding traverses nested objects with single keys, collapsing them into a dotted path.\n* It stops when:\n* - A non-single-key object is encountered\n* - An array is encountered (arrays are not \"single-key objects\")\n* - A primitive value is reached\n* - The flatten depth limit is reached\n* - Any segment fails safe mode validation\n*\n* Safe mode requirements:\n* - `options.keyFolding` must be `'safe'`\n* - Every segment must be a valid identifier (no dots, no special chars)\n* - The folded key must not collide with existing sibling keys\n* - No segment should require quoting\n*\n* @param key - The starting key to fold\n* @param value - The value associated with the key\n* @param siblings - Array of all sibling keys at this level (for collision detection)\n* @param options - Resolved encoding options\n* @returns A FoldResult if folding is possible, undefined otherwise\n*/\nfunction tryFoldKeyChain(key, value, siblings, options, rootLiteralKeys, pathPrefix, flattenDepth) {\n\tif (options.keyFolding !== \"safe\") return;\n\tif (!isJsonObject(value)) return;\n\tconst { segments, tail, leafValue } = collectSingleKeyChain(key, value, flattenDepth ?? options.flattenDepth);\n\tif (segments.length < 2) return;\n\tif (!segments.every((seg) => isIdentifierSegment(seg))) return;\n\tconst foldedKey = buildFoldedKey(segments);\n\tconst absolutePath = pathPrefix ? `${pathPrefix}${DOT}${foldedKey}` : foldedKey;\n\tif (siblings.includes(foldedKey)) return;\n\tif (rootLiteralKeys && rootLiteralKeys.has(absolutePath)) return;\n\treturn {\n\t\tfoldedKey,\n\t\tremainder: tail,\n\t\tleafValue,\n\t\tsegmentCount: segments.length\n\t};\n}\n/**\n* Collects a chain of single-key objects into segments.\n*\n* @remarks\n* Traverses nested objects, collecting keys until:\n* - A non-single-key object is found\n* - An array is encountered\n* - A primitive is reached\n* - An empty object is reached\n* - The depth limit is reached\n*\n* @param startKey - The initial key to start the chain\n* @param startValue - The value to traverse\n* @param maxDepth - Maximum number of segments to collect\n* @returns Object containing segments array, tail value, and leaf value\n*/\nfunction collectSingleKeyChain(startKey, startValue, maxDepth) {\n\tconst segments = [startKey];\n\tlet currentValue = startValue;\n\twhile (segments.length < maxDepth) {\n\t\tif (!isJsonObject(currentValue)) break;\n\t\tconst keys = Object.keys(currentValue);\n\t\tif (keys.length !== 1) break;\n\t\tconst nextKey = keys[0];\n\t\tconst nextValue = currentValue[nextKey];\n\t\tsegments.push(nextKey);\n\t\tcurrentValue = nextValue;\n\t}\n\tif (!isJsonObject(currentValue) || isEmptyObject(currentValue)) return {\n\t\tsegments,\n\t\ttail: void 0,\n\t\tleafValue: currentValue\n\t};\n\treturn {\n\t\tsegments,\n\t\ttail: currentValue,\n\t\tleafValue: currentValue\n\t};\n}\nfunction buildFoldedKey(segments) {\n\treturn segments.join(DOT);\n}\n\n//#endregion\n//#region src/encode/primitives.ts\nfunction encodePrimitive(value, delimiter) {\n\tif (value === null) return NULL_LITERAL;\n\tif (typeof value === \"boolean\") return String(value);\n\tif (typeof value === \"number\") return String(value);\n\treturn encodeStringLiteral(value, delimiter);\n}\nfunction encodeStringLiteral(value, delimiter = DEFAULT_DELIMITER) {\n\tif (isSafeUnquoted(value, delimiter)) return value;\n\treturn `${DOUBLE_QUOTE}${escapeString(value)}${DOUBLE_QUOTE}`;\n}\nfunction encodeKey(key) {\n\tif (isValidUnquotedKey(key)) return key;\n\treturn `${DOUBLE_QUOTE}${escapeString(key)}${DOUBLE_QUOTE}`;\n}\nfunction encodeAndJoinPrimitives(values, delimiter = DEFAULT_DELIMITER) {\n\treturn values.map((v) => encodePrimitive(v, delimiter)).join(delimiter);\n}\nfunction formatHeader(length, options) {\n\tconst key = options?.key;\n\tconst fields = options?.fields;\n\tconst delimiter = options?.delimiter ?? COMMA;\n\tlet header = \"\";\n\tif (key) header += encodeKey(key);\n\theader += `[${length}${delimiter !== DEFAULT_DELIMITER ? delimiter : \"\"}]`;\n\tif (fields) {\n\t\tconst quotedFields = fields.map((f) => encodeKey(f));\n\t\theader += `{${quotedFields.join(delimiter)}}`;\n\t}\n\theader += \":\";\n\treturn header;\n}\n\n//#endregion\n//#region src/encode/encoders.ts\nfunction* encodeJsonValue(value, options, depth) {\n\tif (isJsonPrimitive(value)) {\n\t\tconst encodedPrimitive = encodePrimitive(value, options.delimiter);\n\t\tif (encodedPrimitive !== \"\") yield encodedPrimitive;\n\t\treturn;\n\t}\n\tif (isJsonArray(value)) yield* encodeArrayLines(void 0, value, depth, options);\n\telse if (isJsonObject(value)) yield* encodeObjectLines(value, depth, options);\n}\nfunction* encodeObjectLines(value, depth, options, rootLiteralKeys, pathPrefix, remainingDepth) {\n\tconst keys = Object.keys(value);\n\tif (depth === 0 && !rootLiteralKeys) rootLiteralKeys = new Set(keys.filter((k) => k.includes(\".\")));\n\tconst effectiveFlattenDepth = remainingDepth ?? options.flattenDepth;\n\tfor (const [key, val] of Object.entries(value)) yield* encodeKeyValuePairLines(key, val, depth, options, keys, rootLiteralKeys, pathPrefix, effectiveFlattenDepth);\n}\nfunction* encodeKeyValuePairLines(key, value, depth, options, siblings, rootLiteralKeys, pathPrefix, flattenDepth) {\n\tconst currentPath = pathPrefix ? `${pathPrefix}${DOT}${key}` : key;\n\tconst effectiveFlattenDepth = flattenDepth ?? options.flattenDepth;\n\tif (options.keyFolding === \"safe\" && siblings) {\n\t\tconst foldResult = tryFoldKeyChain(key, value, siblings, options, rootLiteralKeys, pathPrefix, effectiveFlattenDepth);\n\t\tif (foldResult) {\n\t\t\tconst { foldedKey, remainder, leafValue, segmentCount } = foldResult;\n\t\t\tconst encodedFoldedKey = encodeKey(foldedKey);\n\t\t\tif (remainder === void 0) {\n\t\t\t\tif (isJsonPrimitive(leafValue)) {\n\t\t\t\t\tyield indentedLine(depth, `${encodedFoldedKey}: ${encodePrimitive(leafValue, options.delimiter)}`, options.indent);\n\t\t\t\t\treturn;\n\t\t\t\t} else if (isJsonArray(leafValue)) {\n\t\t\t\t\tyield* encodeArrayLines(foldedKey, leafValue, depth, options);\n\t\t\t\t\treturn;\n\t\t\t\t} else if (isJsonObject(leafValue) && isEmptyObject(leafValue)) {\n\t\t\t\t\tyield indentedLine(depth, `${encodedFoldedKey}:`, options.indent);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (isJsonObject(remainder)) {\n\t\t\t\tyield indentedLine(depth, `${encodedFoldedKey}:`, options.indent);\n\t\t\t\tconst remainingDepth = effectiveFlattenDepth - segmentCount;\n\t\t\t\tconst foldedPath = pathPrefix ? `${pathPrefix}${DOT}${foldedKey}` : foldedKey;\n\t\t\t\tyield* encodeObjectLines(remainder, depth + 1, options, rootLiteralKeys, foldedPath, remainingDepth);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\tconst encodedKey = encodeKey(key);\n\tif (isJsonPrimitive(value)) yield indentedLine(depth, `${encodedKey}: ${encodePrimitive(value, options.delimiter)}`, options.indent);\n\telse if (isJsonArray(value)) yield* encodeArrayLines(key, value, depth, options);\n\telse if (isJsonObject(value)) {\n\t\tyield indentedLine(depth, `${encodedKey}:`, options.indent);\n\t\tif (!isEmptyObject(value)) yield* encodeObjectLines(value, depth + 1, options, rootLiteralKeys, currentPath, effectiveFlattenDepth);\n\t}\n}\nfunction* encodeArrayLines(key, value, depth, options) {\n\tif (value.length === 0) {\n\t\tyield indentedLine(depth, formatHeader(0, {\n\t\t\tkey,\n\t\t\tdelimiter: options.delimiter\n\t\t}), options.indent);\n\t\treturn;\n\t}\n\tif (isArrayOfPrimitives(value)) {\n\t\tyield indentedLine(depth, encodeInlineArrayLine(value, options.delimiter, key), options.indent);\n\t\treturn;\n\t}\n\tif (isArrayOfArrays(value)) {\n\t\tif (value.every((arr) => isArrayOfPrimitives(arr))) {\n\t\t\tyield* encodeArrayOfArraysAsListItemsLines(key, value, depth, options);\n\t\t\treturn;\n\t\t}\n\t}\n\tif (isArrayOfObjects(value)) {\n\t\tconst header = extractTabularHeader(value);\n\t\tif (header) yield* encodeArrayOfObjectsAsTabularLines(key, value, header, depth, options);\n\t\telse yield* encodeMixedArrayAsListItemsLines(key, value, depth, options);\n\t\treturn;\n\t}\n\tyield* encodeMixedArrayAsListItemsLines(key, value, depth, options);\n}\nfunction* encodeArrayOfArraysAsListItemsLines(prefix, values, depth, options) {\n\tyield indentedLine(depth, formatHeader(values.length, {\n\t\tkey: prefix,\n\t\tdelimiter: options.delimiter\n\t}), options.indent);\n\tfor (const arr of values) if (isArrayOfPrimitives(arr)) {\n\t\tconst arrayLine = encodeInlineArrayLine(arr, options.delimiter);\n\t\tyield indentedListItem(depth + 1, arrayLine, options.indent);\n\t}\n}\nfunction encodeInlineArrayLine(values, delimiter, prefix) {\n\tconst header = formatHeader(values.length, {\n\t\tkey: prefix,\n\t\tdelimiter\n\t});\n\tconst joinedValue = encodeAndJoinPrimitives(values, delimiter);\n\tif (values.length === 0) return header;\n\treturn `${header} ${joinedValue}`;\n}\nfunction* encodeArrayOfObjectsAsTabularLines(prefix, rows, header, depth, options) {\n\tyield indentedLine(depth, formatHeader(rows.length, {\n\t\tkey: prefix,\n\t\tfields: header,\n\t\tdelimiter: options.delimiter\n\t}), options.indent);\n\tyield* writeTabularRowsLines(rows, header, depth + 1, options);\n}\nfunction extractTabularHeader(rows) {\n\tif (rows.length === 0) return;\n\tconst firstRow = rows[0];\n\tconst firstKeys = Object.keys(firstRow);\n\tif (firstKeys.length === 0) return;\n\tif (isTabularArray(rows, firstKeys)) return firstKeys;\n}\nfunction isTabularArray(rows, header) {\n\tfor (const row of rows) {\n\t\tif (Object.keys(row).length !== header.length) return false;\n\t\tfor (const key of header) {\n\t\t\tif (!(key in row)) return false;\n\t\t\tif (!isJsonPrimitive(row[key])) return false;\n\t\t}\n\t}\n\treturn true;\n}\nfunction* writeTabularRowsLines(rows, header, depth, options) {\n\tfor (const row of rows) yield indentedLine(depth, encodeAndJoinPrimitives(header.map((key) => row[key]), options.delimiter), options.indent);\n}\nfunction* encodeMixedArrayAsListItemsLines(prefix, items, depth, options) {\n\tyield indentedLine(depth, formatHeader(items.length, {\n\t\tkey: prefix,\n\t\tdelimiter: options.delimiter\n\t}), options.indent);\n\tfor (const item of items) yield* encodeListItemValueLines(item, depth + 1, options);\n}\nfunction* encodeObjectAsListItemLines(obj, depth, options) {\n\tif (isEmptyObject(obj)) {\n\t\tyield indentedLine(depth, LIST_ITEM_MARKER, options.indent);\n\t\treturn;\n\t}\n\tconst entries = Object.entries(obj);\n\tconst [firstKey, firstValue] = entries[0];\n\tconst restEntries = entries.slice(1);\n\tif (isJsonArray(firstValue) && isArrayOfObjects(firstValue)) {\n\t\tconst header = extractTabularHeader(firstValue);\n\t\tif (header) {\n\t\t\tyield indentedListItem(depth, formatHeader(firstValue.length, {\n\t\t\t\tkey: firstKey,\n\t\t\t\tfields: header,\n\t\t\t\tdelimiter: options.delimiter\n\t\t\t}), options.indent);\n\t\t\tyield* writeTabularRowsLines(firstValue, header, depth + 2, options);\n\t\t\tif (restEntries.length > 0) yield* encodeObjectLines(Object.fromEntries(restEntries), depth + 1, options);\n\t\t\treturn;\n\t\t}\n\t}\n\tconst encodedKey = encodeKey(firstKey);\n\tif (isJsonPrimitive(firstValue)) yield indentedListItem(depth, `${encodedKey}: ${encodePrimitive(firstValue, options.delimiter)}`, options.indent);\n\telse if (isJsonArray(firstValue)) if (firstValue.length === 0) yield indentedListItem(depth, `${encodedKey}${formatHeader(0, { delimiter: options.delimiter })}`, options.indent);\n\telse if (isArrayOfPrimitives(firstValue)) yield indentedListItem(depth, `${encodedKey}${encodeInlineArrayLine(firstValue, options.delimiter)}`, options.indent);\n\telse {\n\t\tyield indentedListItem(depth, `${encodedKey}${formatHeader(firstValue.length, { delimiter: options.delimiter })}`, options.indent);\n\t\tfor (const item of firstValue) yield* encodeListItemValueLines(item, depth + 2, options);\n\t}\n\telse if (isJsonObject(firstValue)) {\n\t\tyield indentedListItem(depth, `${encodedKey}:`, options.indent);\n\t\tif (!isEmptyObject(firstValue)) yield* encodeObjectLines(firstValue, depth + 2, options);\n\t}\n\tif (restEntries.length > 0) yield* encodeObjectLines(Object.fromEntries(restEntries), depth + 1, options);\n}\nfunction* encodeListItemValueLines(value, depth, options) {\n\tif (isJsonPrimitive(value)) yield indentedListItem(depth, encodePrimitive(value, options.delimiter), options.indent);\n\telse if (isJsonArray(value)) if (isArrayOfPrimitives(value)) yield indentedListItem(depth, encodeInlineArrayLine(value, options.delimiter), options.indent);\n\telse {\n\t\tyield indentedListItem(depth, formatHeader(value.length, { delimiter: options.delimiter }), options.indent);\n\t\tfor (const item of value) yield* encodeListItemValueLines(item, depth + 1, options);\n\t}\n\telse if (isJsonObject(value)) yield* encodeObjectAsListItemLines(value, depth, options);\n}\nfunction indentedLine(depth, content, indentSize) {\n\treturn \" \".repeat(indentSize * depth) + content;\n}\nfunction indentedListItem(depth, content, indentSize) {\n\treturn indentedLine(depth, LIST_ITEM_PREFIX + content, indentSize);\n}\n\n//#endregion\n//#region src/encode/replacer.ts\n/**\n* Applies a replacer function to a `JsonValue` and all its descendants.\n*\n* The replacer is called for:\n* - The root value (with key='', path=[])\n* - Every object property (with the property name as key)\n* - Every array element (with the string index as key: '0', '1', etc.)\n*\n* @param root - The normalized `JsonValue` to transform\n* @param replacer - The replacer function to apply\n* @returns The transformed `JsonValue`\n*/\nfunction applyReplacer(root, replacer) {\n\tconst replacedRoot = replacer(\"\", root, []);\n\tif (replacedRoot === void 0) return transformChildren(root, replacer, []);\n\treturn transformChildren(normalizeValue(replacedRoot), replacer, []);\n}\n/**\n* Recursively transforms the children of a `JsonValue` using the replacer.\n*\n* @param value - The value whose children should be transformed\n* @param replacer - The replacer function to apply\n* @param path - Current path from root\n* @returns The value with transformed children\n*/\nfunction transformChildren(value, replacer, path) {\n\tif (isJsonObject(value)) return transformObject(value, replacer, path);\n\tif (isJsonArray(value)) return transformArray(value, replacer, path);\n\treturn value;\n}\n/**\n* Transforms an object by applying the replacer to each property.\n*\n* @param obj - The object to transform\n* @param replacer - The replacer function to apply\n* @param path - Current path from root\n* @returns A new object with transformed properties\n*/\nfunction transformObject(obj, replacer, path) {\n\tconst result = {};\n\tfor (const [key, value] of Object.entries(obj)) {\n\t\tconst childPath = [...path, key];\n\t\tconst replacedValue = replacer(key, value, childPath);\n\t\tif (replacedValue === void 0) continue;\n\t\tresult[key] = transformChildren(normalizeValue(replacedValue), replacer, childPath);\n\t}\n\treturn result;\n}\n/**\n* Transforms an array by applying the replacer to each element.\n*\n* @param arr - The array to transform\n* @param replacer - The replacer function to apply\n* @param path - Current path from root\n* @returns A new array with transformed elements\n*/\nfunction transformArray(arr, replacer, path) {\n\tconst result = [];\n\tfor (let i = 0; i < arr.length; i++) {\n\t\tconst value = arr[i];\n\t\tconst childPath = [...path, i];\n\t\tconst replacedValue = replacer(String(i), value, childPath);\n\t\tif (replacedValue === void 0) continue;\n\t\tconst normalizedValue = normalizeValue(replacedValue);\n\t\tresult.push(transformChildren(normalizedValue, replacer, childPath));\n\t}\n\treturn result;\n}\n\n//#endregion\n//#region src/index.ts\n/**\n* Encodes a JavaScript value into TOON format string.\n*\n* @param input - Any JavaScript value (objects, arrays, primitives)\n* @param options - Optional encoding configuration\n* @returns TOON formatted string\n*\n* @example\n* ```ts\n* encode({ name: 'Alice', age: 30 })\n* // name: Alice\n* // age: 30\n*\n* encode({ users: [{ id: 1 }, { id: 2 }] })\n* // users[]:\n* //   - id: 1\n* //   - id: 2\n*\n* encode(data, { indent: 4, keyFolding: 'safe' })\n* ```\n*/\nfunction encode(input, options) {\n\treturn Array.from(encodeLines(input, options)).join(\"\\n\");\n}\n/**\n* Decodes a TOON format string into a JavaScript value.\n*\n* @param input - TOON formatted string\n* @param options - Optional decoding configuration\n* @returns Parsed JavaScript value (object, array, or primitive)\n*\n* @example\n* ```ts\n* decode('name: Alice\\nage: 30')\n* // { name: 'Alice', age: 30 }\n*\n* decode('users[]:\\n  - id: 1\\n  - id: 2')\n* // { users: [{ id: 1 }, { id: 2 }] }\n*\n* decode(toonString, { strict: false, expandPaths: 'safe' })\n* ```\n*/\nfunction decode(input, options) {\n\treturn decodeFromLines(input.split(\"\\n\"), options);\n}\n/**\n* Encodes a JavaScript value into TOON format as a sequence of lines.\n*\n* This function yields TOON lines one at a time without building the full string,\n* making it suitable for streaming large outputs to files, HTTP responses, or process stdout.\n*\n* @param input - Any JavaScript value (objects, arrays, primitives)\n* @param options - Optional encoding configuration\n* @returns Iterable of TOON lines (without trailing newlines)\n*\n* @example\n* ```ts\n* // Stream to stdout\n* for (const line of encodeLines({ name: 'Alice', age: 30 })) {\n*   console.log(line)\n* }\n*\n* // Collect to array\n* const lines = Array.from(encodeLines(data))\n*\n* // Equivalent to encode()\n* const toonString = Array.from(encodeLines(data, options)).join('\\n')\n* ```\n*/\nfunction encodeLines(input, options) {\n\tconst normalizedValue = normalizeValue(input);\n\tconst resolvedOptions = resolveOptions(options);\n\treturn encodeJsonValue(resolvedOptions.replacer ? applyReplacer(normalizedValue, resolvedOptions.replacer) : normalizedValue, resolvedOptions, 0);\n}\n/**\n* Decodes TOON format from pre-split lines into a JavaScript value.\n*\n* This is a convenience wrapper around the streaming decoder that builds\n* the full value in memory. Useful when you already have lines as an array\n* or iterable and want the standard decode behavior with path expansion support.\n*\n* @param lines - Iterable of TOON lines (without newlines)\n* @param options - Optional decoding configuration (supports expandPaths)\n* @returns Parsed JavaScript value (object, array, or primitive)\n*\n* @example\n* ```ts\n* const lines = ['name: Alice', 'age: 30']\n* decodeFromLines(lines)\n* // { name: 'Alice', age: 30 }\n* ```\n*/\nfunction decodeFromLines(lines, options) {\n\tconst resolvedOptions = resolveDecodeOptions(options);\n\tconst decodedValue = buildValueFromEvents(decodeStreamSync$1(lines, {\n\t\tindent: resolvedOptions.indent,\n\t\tstrict: resolvedOptions.strict\n\t}));\n\tif (resolvedOptions.expandPaths === \"safe\") return expandPathsSafe(decodedValue, resolvedOptions.strict);\n\treturn decodedValue;\n}\n/**\n* Synchronously decodes TOON lines into a stream of JSON events.\n*\n* This function yields structured events (startObject, endObject, startArray, endArray,\n* key, primitive) that represent the JSON data model without building the full value tree.\n* Useful for streaming processing, custom transformations, or memory-efficient parsing.\n*\n* @remarks\n* Path expansion (`expandPaths: 'safe'`) is not supported in streaming mode.\n*\n* @param lines - Iterable of TOON lines (without newlines)\n* @param options - Optional decoding configuration (expandPaths not supported)\n* @returns Iterable of JSON stream events\n*\n* @example\n* ```ts\n* const lines = ['name: Alice', 'age: 30']\n* for (const event of decodeStreamSync(lines)) {\n*   console.log(event)\n*   // { type: 'startObject' }\n*   // { type: 'key', key: 'name' }\n*   // { type: 'primitive', value: 'Alice' }\n*   // ...\n* }\n* ```\n*/\nfunction decodeStreamSync(lines, options) {\n\treturn decodeStreamSync$1(lines, options);\n}\n/**\n* Asynchronously decodes TOON lines into a stream of JSON events.\n*\n* This function yields structured events (startObject, endObject, startArray, endArray,\n* key, primitive) that represent the JSON data model without building the full value tree.\n* Supports both sync and async iterables for maximum flexibility with file streams,\n* network responses, or other async sources.\n*\n* @remarks\n* Path expansion (`expandPaths: 'safe'`) is not supported in streaming mode.\n*\n* @param source - Async or sync iterable of TOON lines (without newlines)\n* @param options - Optional decoding configuration (expandPaths not supported)\n* @returns Async iterable of JSON stream events\n*\n* @example\n* ```ts\n* const fileStream = createReadStream('data.toon', 'utf-8')\n* const lines = splitLines(fileStream) // Async iterable of lines\n*\n* for await (const event of decodeStream(lines)) {\n*   console.log(event)\n*   // { type: 'startObject' }\n*   // { type: 'key', key: 'name' }\n*   // { type: 'primitive', value: 'Alice' }\n*   // ...\n* }\n* ```\n*/\nfunction decodeStream(source, options) {\n\treturn decodeStream$1(source, options);\n}\nfunction resolveOptions(options) {\n\treturn {\n\t\tindent: options?.indent ?? 2,\n\t\tdelimiter: options?.delimiter ?? DEFAULT_DELIMITER,\n\t\tkeyFolding: options?.keyFolding ?? \"off\",\n\t\tflattenDepth: options?.flattenDepth ?? Number.POSITIVE_INFINITY,\n\t\treplacer: options?.replacer\n\t};\n}\nfunction resolveDecodeOptions(options) {\n\treturn {\n\t\tindent: options?.indent ?? 2,\n\t\tstrict: options?.strict ?? true,\n\t\texpandPaths: options?.expandPaths ?? \"off\"\n\t};\n}\n\n//#endregion\nexport { DEFAULT_DELIMITER, DELIMITERS, decode, decodeFromLines, decodeStream, decodeStreamSync, encode, encodeLines };", "\nimport { encode, decode } from '@toon-format/toon';\n\n// \u66B4\u9732\u5168\u5C40 API\nwindow.TOON = {\n  encode,\n  decode,\n\n  // TOON \u683C\u5F0F\u68C0\u6D4B\u51FD\u6570\n  isToonFormat(content) {\n    if (typeof content !== 'string' || content.trim().length === 0) {\n      return false;\n    }\n\n    const lines = content.split('\\n');\n    let toonLineCount = 0;\n\n    for (const line of lines) {\n      const trimmed = line.trim();\n      if (!trimmed) continue;\n\n      // \u68C0\u6D4B TOON \u683C\u5F0F\u7684\u4E09\u79CD\u5178\u578B\u6A21\u5F0F\uFF1A\n      // 1. \u8868\u5934\u884C\uFF1Akey[N] \u6216 key[N]{fields}\n      if (/^[^:\\s]+\\[\\d+\\](?:\\{[^}]+\\})?:/.test(trimmed)) {\n        toonLineCount++;\n      }\n      // 2. \u6570\u636E\u884C\uFF1A\u4EE5\u9017\u53F7\u3001\u5236\u8868\u7B26\u6216\u7BA1\u9053\u7B26\u5206\u9694\u7684\u503C\n      else if (/^(?:[^,\\t|]+[,\\t|])+[^,\\t|]*$/.test(trimmed)) {\n        toonLineCount++;\n      }\n      // 3. \u7F29\u8FDB\u884C\uFF1A\u4EE5\u7A7A\u683C\u5F00\u5934\u7684\u952E\u503C\u5BF9\u6216\u6570\u636E\n      else if (/^\\s{2,}/.test(line)) {\n        toonLineCount++;\n      }\n\n      // \u81F3\u5C11 2 \u884C\u5339\u914D\u5219\u8BA4\u4E3A\u662F TOON \u683C\u5F0F\n      if (toonLineCount >= 2) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n};\n"],
  "mappings": "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",
  "names": []
}
